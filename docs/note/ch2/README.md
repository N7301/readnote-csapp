---
title: Chapter 2 信息的处理与表示
---

Chapter 2 信息的处理与表示

[[toc]]

# （一） 信息存储

## 1.1. 十六进制数

位权  16<sup>i</sup> 

“十六进制 <=> 十进制” 的窍门： A-10  C-12  F-15

## 1.2. 进制转换

### 1.2.1. 二进制 <-> 十六进制

### 1.2.2. 十进制 <-> K 进制

#### **整数的情况**：

1. 整数部分不断除以基数 K，并记下余数，直至商为 0 为止。
2. 从最后一个余数起，逆向取各个余数，则为转换后的 K 进制数。

#### **小数的情况**：

乘以基数 K，记录整数部分，直至小数部分为 0 为止。

小数转换若无法乘到为 0，则选取一定精度（位数）。

### 1.2.3. K进制 <-> 十进制

按权展开

## 1.3. 编码

### 1.3.1. 编码长度

+ 字长 -> 指针的标称长度 -> 虚拟地址空间的最大大小

+ C 语言的 type size

### 1.3.2. 寻址与字节序

对于跨越多字节的 object，必须建立两个规律：① 这个 obj 的地址是什么？② 在内存中如何排列这些字节？

**寻址**：对象的地址为所使用字节中最小的地址

**字节序**：大端序与小端序

字节序变得重要的三个情况：

1. 网络传输
2. 阅读字节序列
3. 当编写规避正常的类型系统程序时

# （二）位的运算

## 2.1. 布尔代数

+ `&` AND 与
+ `|` OR 或
+ `~` NOT 非
+ `^` XOR 异或

**布尔环**：长度为 w 的位向量上的 ^ & ~ 运算

布尔环中“加法”是 `^`，其加法逆元是其本身，如 a ^ a = 0

**应用于集合**：`|`、`&` 对应于集合的并、交，`~` 对应于补

## 2.2. C 语言的位级运算

`& | ~ ^`

### 2.2.1. 巧用异或

```c
void inplace_swap(int* x, int* y) {
    *y = *x ^ *y;
    *x = *x ^ *y;
    *y = *x ^ *y;
}
```

::: warning
但该程序隐含是 x、y 不是同一个地址，否则 `*x ^ *y` 后直接全 0
:::

### 2.2.2. 掩码运算

技巧：表达式 `~0` 生成一个全1的掩码

## 2.3. 对比 C 语言的逻辑元素

`&& || ! `

+ 运算结果为 0 或 1，大小为一个 byte
+ 具有**短路求值**（"提前终止"）的特性

## 2.4. C 语言的移位运算

### 左移

**逻辑左移**  `x << k`

### 右移

+ **逻辑右移**：左边填 0
+ **算术右移**：左边补 MST 的值

::: tip
C 语言未明确定义采用哪种
:::

# （三）整数表示

## 3.1. 无符号数的编码


$$B2U_w(\vec{x}) \triangleq \sum_{i=0}^{w-1}{x_i 2^i}$$

+ 编码具有唯一性

## 3.2. 补码编码

$$B2T_w(\vec{x}) \triangleq -x_{w-1} 2^{w-1} + \sum_{i=0}^{w-2}{x_i 2^i}$$

+ MST 的 $2_{w-1}$ 称为**符号位**，权重 $-2^{w-1}$
+ 取值范围：[$-2^{w-1}$, $2^{w-1} - 1$]
+ 补码编码也具有唯一性
+ 两个值得注意的数学特性：
  1. 非对称： $|TMin| = TMax + 1$
  2. 最大值与无符号数的关系：$UMax = 2 \times TMax + 1$

C 语言的常量声明：`#include <limits.h>`

## 3.3. 无符号数与有符号数之间的转换

> 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

### （1）补码 -> 无符号数

![](./images/2021-07-16-23-10-31.png)

+ 其实就是把符号位的权重由 $-2^{w-1}$ 逆转为 $2^{w-1}$
### （2）无符号数 -> 补码

![](./images/2021-07-16-23-11-17.png)

+ 其实就是将符号位的权重由 $2^{w-1}$ 逆转为 $-2^{w-1}$

### （3）C 语言类型转换产生的奇怪行为

expr 中有 signed 和 unsigned 混用时，有符号隐式地转换为无符号，包括比较运算符 `< > == <= >=`。

例如，-1 < 0U <=> 4294967295U < 0U  =>  False

### （4）无符号与有符号转换的基本原则：

1. 位模式不变
2. 重新解读
3. 会有意外的数值变化：被 $\pm2^w$
4. 表达式中混用时的隐式转换

## 3.4 扩展

扩展：不同字长之间的转换，同时又保持数值不变

+ **零扩展** -> 无符号数：前面填 0

+ **符号扩展** -> 有符号数：前面填 MSB 位（符号位）

> 当执行强制类型转换既涉及大小变化又涉及符号变化时，应该先改变大小再转变符号。 eg：short -> int -> unsigned int

## 3.5 截断

**截断**：减少表示一个数字的位数（如 int -> short）

基本原则：
1. 无论是有符号数/无符号数，多出的位均被截断
2. 结果重新解读

### （1）截断无符号数

w 位的 $\vec{x}=[x_{w-1}, x_{w-2}, ..., x_{0}]$ --截断--> k 位的$\vec{x}^{\prime}=[x_{k-1}, x_{k-2}, ..., x_{0}]$

${x^{\prime}}$ = $x$ mod $2^k$, 其中 $x = B2U(\vec{x})$, $x^{\prime}=B2U(\vec{x})$

### （2）截断有符号数

w 位的 $\vec{x}=[x_{w-1}, x_{w-2}, ..., x_{0}]$ --截断--> k 位的$\vec{x}^{\prime}=[x_{k-1}, x_{k-2}, ..., x_{0}]$

${x^{\prime}} = U2T(x \mod 2^k)$, 其中 $x=B2U(\vec{x})$, $x^{\prime}=B2U(\vec{x})$

::: tip
上面的过程就是按照 unsigned 解读位模式，截断至 k 位，即原 unsigned 值 mod $2^k$
:::

## 3.6 无符号数与有符号数的使用

隐式转换产生了很多 bug，除非已经知道隐含的转换规则，否则不要使用。

使用 unsigned 的两种情况：
1. 进行模运算和多精度运算时（此时数字由字的数组表示）
2. 用二进制位表示集合时

# （四）整数运算

## 4.1 无符号加法 UAdd

两个 w 位 unsigned 相加 -> 真实和需要 w+1 位 -> 丢弃进位，得到 w 位

**模数加法**：![](./images/2021-07-18-08-15-08.png)

**检测溢出**：$s = x + y$，当且仅当 $s > x（或 s > y）$ 时溢出。

## 4.2 补码加法 TAdd

TAdd 与 UAdd 有着完全相同的位级表现。

**功能**：
1. 真实和需要 w+1 位
2. 丢弃 MSB 位
3. 将剩余位视为补码整数

**补码加法**：![](./images/2021-07-18-08-23-21.png)

**检测溢出**：s = x + y，若 x > 0, y > 0 但 s <= 0，则正溢出；若 x < 0, y < 0 但 s >= 0，则负溢出。

## 4.3 阿贝尔群 Abelian Group

模数加法形成了阿贝尔群，表示为 <$2^w$, +>.

特性：封闭性、交换性、结合性、单位元 0、有加法逆元（$u$ 与 $2^w - u$）

TAdd 与带 UAdd 加法的无符号数是同构群（因为有着相同的位模式）

补码加法也构成一个群： ![](./images/2021-07-18-08-28-07.png)

## 4.4 无符号数求反

w 位的 $x$ 其无符号逆元：![](./images/2021-07-18-08-29-41.png)

## 4.5 有符号数补码取非

w 位的 $x$ 其补码取非：![](./images/2021-07-18-08-28-07.png)

+ signed 和 unsigned 的非产生的位模式是相同的，都是**各位取反再加1**。

## 4.6 无符号数乘法

两个 w 位的 unsigned 相乘 --> 真实结果需要 $2^w$ 位 --> 丢弃高 w 位，保留低 w 位

$$ x * y = (x \cdot y) \mod 2^w$$

## 4.7 补码乘法

$$ x * y = U2T_w ((x \cdot y) \mod 2^w)$$ 

+ unsigned 和 signed 乘法具有位级等价性（完整的乘积位级可能不同，但截断后的位级相同）

## 4.8 乘以常数

编译器经常试着用移位和加法运算的组合来代替乘以常数的乘法

u << k 等价于 $u * 2^k$ （无论 u 是 unsigned 还是 signed）