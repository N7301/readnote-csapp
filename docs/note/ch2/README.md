---
title: Chapter 2 信息的处理与表示
---

Chapter 2 信息的处理与表示

[[toc]]

# （一） 信息存储

## 1.1. 十六进制数

位权  16<sup>i</sup> 

“十六进制 <=> 十进制” 的窍门： A-10  C-12  F-15

## 1.2. 进制转换

### 1.2.1. 二进制 <-> 十六进制

### 1.2.2. 十进制 <-> K 进制

#### **整数的情况**：

1. 整数部分不断除以基数 K，并记下余数，直至商为 0 为止。
2. 从最后一个余数起，逆向取各个余数，则为转换后的 K 进制数。

#### **小数的情况**：

乘以基数 K，记录整数部分，直至小数部分为 0 为止。

小数转换若无法乘到为 0，则选取一定精度（位数）。

### 1.2.3. K进制 <-> 十进制

按权展开

## 1.3. 编码

### 1.3.1. 编码长度

+ 字长 -> 指针的标称长度 -> 虚拟地址空间的最大大小

+ C 语言的 type size

### 1.3.2. 寻址与字节序

对于跨越多字节的 object，必须建立两个规律：① 这个 obj 的地址是什么？② 在内存中如何排列这些字节？

**寻址**：对象的地址为所使用字节中最小的地址

**字节序**：大端序与小端序

字节序变得重要的三个情况：

1. 网络传输
2. 阅读字节序列
3. 当编写规避正常的类型系统程序时

# （二）位的运算

## 2.1. 布尔代数

+ `&` AND 与
+ `|` OR 或
+ `~` NOT 非
+ `^` XOR 异或

**布尔环**：长度为 w 的位向量上的 ^ & ~ 运算

布尔环中“加法”是 `^`，其加法逆元是其本身，如 a ^ a = 0

**应用于集合**：`|`、`&` 对应于集合的并、交，`~` 对应于补

## 2.2. C 语言的位级运算

`& | ~ ^`

### 2.2.1. 巧用异或

```c
void inplace_swap(int* x, int* y) {
    *y = *x ^ *y;
    *x = *x ^ *y;
    *y = *x ^ *y;
}
```

::: warning
但该程序隐含是 x、y 不是同一个地址，否则 `*x ^ *y` 后直接全 0
:::

### 2.2.2. 掩码运算

技巧：表达式 `~0` 生成一个全1的掩码

## 2.3. 对比 C 语言的逻辑元素

`&& || ! `

+ 运算结果为 0 或 1，大小为一个 byte
+ 具有**短路求值**（"提前终止"）的特性

## 2.4. C 语言的移位运算

### 左移

**逻辑左移**  `x << k`

### 右移

+ **逻辑右移**：左边填 0
+ **算术右移**：左边补 MST 的值

::: tip
C 语言未明确定义采用哪种
:::

# （三）整数表示

## 3.1. 无符号数的编码


$$B2U_w(\vec{x}) \triangleq \sum_{i=0}^{w-1}{x_i 2^i}$$

+ 编码具有唯一性

## 3.2. 补码编码

$$B2T_w(\vec{x}) \triangleq -x_{w-1} 2^{w-1} + \sum_{i=0}^{w-2}{x_i 2^i}$$

+ MST 的 $x_w-1$ 称为**符号位**，权重 $-2^{w-1}$
+ 取值范围：[$-2^{w-1}$, $x^{w-1} - 1$]
+ 补码编码也具有唯一性
+ 两个值得注意的数学特性：
  1. 非对称： $|TMin| = TMax + 1$
  2. 最大值与无符号数的关系：$UMax = 2 \times TMax + 1$

C 语言的常量声明：`#include <limits.h>`

## 3.3. 无符号数与有符号数之间的转换

> 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

### （1）补码 -> 无符号数

![](./images/2021-07-16-23-10-31.png)

+ 其实就是把符号位的权重由 $-2^{w-1}$ 逆转为 $2^{w-1}$
### （2）无符号数 -> 补码

![](./images/2021-07-16-23-11-17.png)

+ 其实就是将符号位的权重由 $2^{w-1}$ 逆转为 $-2^{w-1}$

### （3）C 语言类型转换产生的奇怪行为

expr 中有 signed 和 unsigned 混用时，有符号隐式地转换为无符号，包括比较运算符 `< > == <= >=`。

例如，-1 < 0U <=> 4294967295U < 0U  =>  False

### （4）无符号与有符号转换的基本原则：

1. 位模式不变
2. 重新解读
3. 会有意外的数值变化：被 $\pm2^w$
4. 表达式中混用时的隐式转换

## 3.4 扩展

扩展：不同字长之间的转换，同时又保持数值不变

+ **零扩展** -> 无符号数：前面填 0

+ **符号扩展** -> 有符号数：前面填 MSB 位（符号位）

> 当执行强制类型转换既涉及大小变化又涉及符号变化时，应该先改变大小再转变符号。 eg：short -> int -> unsigned int

